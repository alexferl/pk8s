package pk8s

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"regexp"
	"slices"
	"sort"
	"strings"
	"text/template"

	"github.com/ettle/strcase"
	"github.com/rs/zerolog/log"
	"gopkg.in/yaml.v3"
)

type CRD struct {
	Spec Spec `yaml:"spec"`
}

type Spec struct {
	Group    string    `yaml:"group"`
	Names    Names     `yaml:"names"`
	Versions []Version `yaml:"versions"`
}

type Names struct {
	Kind     string `yaml:"kind"`
	ListKind string `yaml:"listKind"`
	Singular string `yaml:"singular"`
}

type Version struct {
	Schema struct {
		OpenAPIV3Schema Property `yaml:"openAPIV3Schema"`
	} `yaml:"schema"`
}

type Property struct {
	Type        string              `yaml:"type"`
	Description string              `yaml:"description,omitempty"`
	Properties  map[string]Property `yaml:"properties,omitempty"`
	Items       *Property           `yaml:"items,omitempty"`
	Required    []string            `yaml:"required,omitempty"`
}

type File struct {
	Body    string
	Dir     string
	Imports []string
	Name    string
	Package string

	data bytes.Buffer
}

func (f *File) String() string {
	f.Body = f.data.String()
	return f.Body
}

func (f *File) WriteString(s string) {
	_, err := f.data.WriteString(s)
	if err != nil {
		log.Fatal().Msgf("failed writing to buffer: %v", err)
	}

	f.Body = f.String()
}

type Importer interface {
	Read(path string) ([]byte, error)
	Import(data []byte) error
}

type GroupItems struct {
	Group string
	Items []string
}

type importer struct {
	config   *ImporterConfig
	files    []File
	name     *string
	groupMap map[string]*GroupItems
}

type ImporterConfig struct {
	Overwrite bool
}

func NewImporter(config *ImporterConfig) Importer {
	return &importer{
		config:   config,
		groupMap: make(map[string]*GroupItems),
	}
}

func (i *importer) Read(path string) ([]byte, error) {
	if name, value, ok := hasCustomName(path); ok {
		i.name = &name
		path = value
	}

	var data []byte
	var err error

	if path == "" || path == "-" {
		log.Debug().Msg("importer detected stdin path")

		data, err = io.ReadAll(os.Stdin)
		if err != nil {
			return nil, err
		}
	} else if isHTTPLink(path) {
		log.Debug().Msg("importer detected HTTP link")

		resp, respErr := http.Get(path)
		if respErr != nil {
			return nil, err
		}
		defer resp.Body.Close()

		data, err = io.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}
	} else {
		log.Debug().Msg("importer detected file path")

		data, err = os.ReadFile(path)
		if err != nil {
			return nil, err
		}
	}

	return data, nil
}

func (i *importer) Import(data []byte) error {
	var crds []CRD
	decoder := yaml.NewDecoder(bytes.NewReader(data))
	for {
		var crd CRD
		err := decoder.Decode(&crd)
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}
		crds = append(crds, crd)
	}

	fmt.Println("Importing custom resource definitions, this may take a few moments...")
	for _, crd := range crds {
		err := i.importCRD(crd)
		if err != nil {
			return err
		}
	}

	err := i.write()
	if err != nil {
		return err
	}

	err = runGoFmt("imports")
	if err != nil {
		return err
	}

	i.print()

	return nil
}

func (i *importer) importCRD(crd CRD) error {
	schema := crd.Spec.Versions[0].Schema.OpenAPIV3Schema
	group := crd.Spec.Group
	groupSnake := strcase.ToSnake(group)
	singular := crd.Spec.Names.Singular
	kindPrefix := strcase.ToPascal(crd.Spec.Names.Kind)

	if _, ok := i.groupMap[group]; !ok {
		i.groupMap[group] = &GroupItems{Group: group}
	}
	i.groupMap[group].Items = append(i.groupMap[group].Items, fmt.Sprintf("%s/%s", group, singular))

	name := kindPrefix
	if i.name != nil {
		name = *i.name
	}

	name = strcase.ToSnake(name)
	path := fmt.Sprintf("imports/%s", groupSnake)

	fileName := fmt.Sprintf("%s/%s.go", path, name)
	file := File{
		Dir:     path,
		Name:    fileName,
		Package: groupSnake,
	}

	generateStructs(&file, kindPrefix, schema)
	listKind := strcase.ToGoPascal(crd.Spec.Names.ListKind)
	if listKind != "" {
		generateListStruct(&file, listKind, kindPrefix, schema)
	}

	i.files = append(i.files, file)

	return nil
}

const fileTemplate = `// Code generated by pk8s; DO NOT EDIT.

package {{.Package}}
{{ if .Imports}}
import (
{{- range .Imports}}
	"{{.}}"
{{- end}}
){{end}}

{{.Body}}

`

func (i *importer) write() error {
	for _, file := range i.files {
		if err := createDirectory(file.Dir, false); err != nil {
			return fmt.Errorf("failed to create directory %s: %v", file.Dir, err)
		}

		_, err := os.Stat(file.Name)
		if err == nil {
			if !i.config.Overwrite {
				return fmt.Errorf("file %s already exists", file.Name)
			}
		} else if !os.IsNotExist(err) {
			return fmt.Errorf("failed checking file %s: %v", file.Name, err)
		}

		err = writeFile(file)
		if err != nil {
			return err
		}
	}

	return nil
}

func (i *importer) print() {
	var groups []GroupItems
	for _, g := range i.groupMap {
		groups = append(groups, *g)
	}

	sort.Slice(groups, func(i, j int) bool {
		return groups[i].Group < groups[j].Group
	})

	for _, g := range groups {
		fmt.Println(g.Group)

		sort.Strings(g.Items)

		for _, item := range g.Items {
			fmt.Printf("  %s\n", item)
		}
	}
}

func writeFile(file File) error {
	out, err := os.Create(file.Name)
	if err != nil {
		return fmt.Errorf("failed creating file %s: %v", file.Name, err)
	}

	defer out.Close()

	tmpl, err := template.New("fileTemplate").Parse(fileTemplate)
	if err != nil {
		return fmt.Errorf("failed creating template: %v", err)
	}

	err = tmpl.Execute(out, file)
	if err != nil {
		return fmt.Errorf("failed rendering template: %v", err)
	}

	return nil
}

func generateStructs(file *File, prefix string, prop Property) {
	structName := prefix
	file.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	generateStructFields(file, structName, prop, nil)
	file.WriteString("}\n\n")

	for fieldName, fieldProp := range prop.Properties {
		if fieldName != "metadata" && fieldProp.Type == "object" && len(fieldProp.Properties) > 0 {
			generateStructs(file, prefix+strcase.ToGoPascal(fieldName), fieldProp)
		} else if fieldProp.Type == "array" && fieldProp.Items != nil && fieldProp.Items.Type == "object" {
			generateStructs(file, prefix+strcase.ToGoPascal(fieldName)+"Item", *fieldProp.Items)
		}
	}
}

func generateStructFields(file *File, name string, prop Property, excludeFields []string) {
	requiredFields := make(map[string]bool)
	for _, field := range prop.Required {
		requiredFields[field] = true
	}

	for fieldName, fieldProp := range prop.Properties {
		if slices.Contains(excludeFields, fieldName) {
			continue
		}
		pascalFieldName := strcase.ToGoPascal(fieldName)
		var fieldType string
		if fieldName == "metadata" {
			fieldType = "*k8s.ObjectMetaV1"
			if !slices.Contains(file.Imports, "github.com/alexferl/pk8s/k8s") {
				file.Imports = append(file.Imports, "github.com/alexferl/pk8s/k8s")
			}
		} else {
			fieldType = getGoType(name+pascalFieldName, fieldProp)
		}

		if fieldProp.Description != "" {
			file.WriteString(fmt.Sprintf("\t// %s\n", strings.ReplaceAll(fieldProp.Description, "\n", " ")))
		}
		tag := fmt.Sprintf(`json:"%s`, fieldName)
		if !requiredFields[fieldName] {
			tag += ",omitempty"
			if !strings.HasPrefix(fieldType, "[]") && !strings.HasPrefix(fieldType, "*") && fieldType != "map[string]interface{}" {
				fieldType = "*" + fieldType
			}
		}
		tag += `"`
		file.WriteString(fmt.Sprintf("\t%s %s `%s`\n", pascalFieldName, fieldType, tag))
	}
}

func generateListStruct(file *File, listKind, itemKind string, schema Property) {
	file.WriteString(fmt.Sprintf("type %s struct {\n", listKind))
	generateStructFields(file, listKind, schema, []string{"spec", "status"})
	file.WriteString(fmt.Sprintf("\tItems []%s `json:\"items\"`\n", itemKind))
	file.WriteString("}\n\n")
}

func getGoType(name string, prop Property) string {
	switch prop.Type {
	case "string":
		return "string"
	case "integer":
		return "int"
	case "boolean":
		return "bool"
	case "array":
		if prop.Items != nil {
			itemType := getGoType(name+"Item", *prop.Items)
			if prop.Items.Type == "object" {
				itemType = strcase.ToGoPascal(name + "Item")
			}
			return "[]" + itemType
		}
		return "[]interface{}"
	case "object":
		if len(prop.Properties) > 0 {
			return strcase.ToGoPascal(name)
		}
		return "map[string]interface{}"
	default:
		return "interface{}"
	}
}

func hasCustomName(input string) (string, string, bool) {
	pattern := `^(\w+):=(.*)$`
	re := regexp.MustCompile(pattern)

	matches := re.FindStringSubmatch(input)
	if len(matches) == 3 {
		name := matches[1]
		value := matches[2]
		return name, value, true
	} else {
		return "", "", false
	}
}

func isHTTPLink(s string) bool {
	u, err := url.Parse(s)
	if err != nil {
		return false
	}
	return u.Scheme == "http" || u.Scheme == "https"
}

func runGoFmt(dir string) error {
	cmd := exec.Command("go", "fmt", "./...")
	cmd.Dir = dir
	_, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("go fmt failed: %v", err)
	}
	return nil
}
