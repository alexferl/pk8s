package pk8s

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"slices"
	"strings"

	"github.com/ettle/strcase"
	"github.com/rs/zerolog/log"
	"gopkg.in/yaml.v3"
)

type CRD struct {
	APIVersion string `yaml:"apiVersion"`
	Kind       string `yaml:"kind"`
	Metadata   struct {
		Name string `yaml:"name"`
	} `yaml:"metadata"`
	Spec Spec `yaml:"spec"`
}

type Spec struct {
	Group    string    `yaml:"group"`
	Names    Names     `yaml:"names"`
	Versions []Version `yaml:"versions"`
}

type Names struct {
	Kind       string   `yaml:"kind"`
	ListKind   string   `yaml:"listKind"`
	Plural     string   `yaml:"plural"`
	Singular   string   `yaml:"singular"`
	ShortNames []string `yaml:"shortNames,omitempty"`
	Categories []string `yaml:"categories,omitempty"`
}

type Version struct {
	Name   string `yaml:"name"`
	Schema struct {
		OpenAPIV3Schema Property `yaml:"openAPIV3Schema"`
	} `yaml:"schema"`
}

type Property struct {
	Type        string              `yaml:"type"`
	Description string              `yaml:"description,omitempty"`
	Properties  map[string]Property `yaml:"properties,omitempty"`
	Items       *Property           `yaml:"items,omitempty"`
	Required    []string            `yaml:"required,omitempty"`
}

type Importer interface {
	Read(path string) ([]byte, error)
	Import(data []byte) error
}

type File struct {
	Name string
	Dir  string
	Data bytes.Buffer
}

type importer struct {
	config *ImporterConfig
	files  []File
	name   *string
}

type ImporterConfig struct {
	Overwrite bool
}

func NewImporter(config *ImporterConfig) Importer {
	return &importer{
		config: config,
	}
}

func (i *importer) Read(path string) ([]byte, error) {
	if name, value, ok := hasCustomName(path); ok {
		i.name = &name
		path = value
	}

	var data []byte
	var err error

	if path == "" || path == "-" {
		log.Debug().Msg("importer detected stdin path")

		data, err = io.ReadAll(os.Stdin)
		if err != nil {
			return nil, err
		}
	} else if isHTTPLink(path) {
		log.Debug().Msg("importer detected HTTP link")

		resp, respErr := http.Get(path)
		if respErr != nil {
			return nil, err
		}
		defer resp.Body.Close()

		data, err = io.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}
	} else {
		log.Debug().Msg("importer detected file path")

		data, err = os.ReadFile(path)
		if err != nil {
			return nil, err
		}
	}

	return data, nil
}

func (i *importer) Import(data []byte) error {
	var crds []CRD
	decoder := yaml.NewDecoder(bytes.NewReader(data))
	for {
		var crd CRD
		err := decoder.Decode(&crd)
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}
		crds = append(crds, crd)
	}

	for _, crd := range crds {
		err := i.importCRD(crd)
		if err != nil {
			return err
		}
	}

	err := i.write()
	if err != nil {
		return err
	}

	err = RunGoFmt("imports")
	if err != nil {
		return err
	}

	err = RunGoImports("imports")
	if err != nil {
		return err
	}

	return nil
}

func (i *importer) importCRD(crd CRD) error {
	schema := crd.Spec.Versions[0].Schema.OpenAPIV3Schema
	group := strcase.ToSnake(crd.Spec.Group)
	kindPrefix := strcase.ToPascal(crd.Spec.Names.Kind)

	name := kindPrefix
	if i.name != nil {
		name = *i.name
	}

	name = strcase.ToSnake(name)
	path := fmt.Sprintf("imports/%s", group)

	fileName := fmt.Sprintf("%s/%s.go", path, name)
	file := File{
		Name: fileName,
		Dir:  path,
	}

	header := fmt.Sprintf(`// Code generated by pk8s; DO NOT EDIT.

package %s

import (
    "github.com/alexferl/pk8s/k8s"
)`, group)

	_, err := file.Data.WriteString(header + "\n\n")
	if err != nil {
		return fmt.Errorf("failed writing to file %s: %v", fileName, err)
	}

	generateStructs(&file.Data, kindPrefix, schema)
	listKind := strcase.ToGoPascal(crd.Spec.Names.ListKind)
	if listKind != "" {
		generateListStruct(&file.Data, listKind, kindPrefix, schema)
	}

	i.files = append(i.files, file)

	return nil
}

func (i *importer) write() error {
	for _, f := range i.files {
		if err := createDirectory(f.Dir, false); err != nil {
			return fmt.Errorf("failed to create directory %s: %v", f.Dir, err)
		}

		_, err := os.Stat(f.Name)
		if err == nil {
			if !i.config.Overwrite {
				return fmt.Errorf("file %s already exists", f.Name)
			}
		} else if !os.IsNotExist(err) {
			return fmt.Errorf("failed checking file %s: %v", f.Name, err)
		}

		file, err := os.Create(f.Name)
		if err != nil {
			return fmt.Errorf("failed creating file %s: %v", f.Name, err)
		}

		_, err = file.Write(f.Data.Bytes())
		if err != nil {
			file.Close()
			return fmt.Errorf("failed writing to file %s: %v", f.Name, err)
		}

		err = file.Close()
		if err != nil {
			return fmt.Errorf("failed closing file %s: %v", f.Name, err)
		}
	}

	return nil
}

func generateStructs(file *bytes.Buffer, prefix string, prop Property) {
	structName := prefix
	file.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	generateStructFields(file, structName, prop, nil)
	file.WriteString("}\n\n")

	for fieldName, fieldProp := range prop.Properties {
		if fieldName != "metadata" && fieldProp.Type == "object" && len(fieldProp.Properties) > 0 {
			generateStructs(file, prefix+strcase.ToGoPascal(fieldName), fieldProp)
		} else if fieldProp.Type == "array" && fieldProp.Items != nil && fieldProp.Items.Type == "object" {
			generateStructs(file, prefix+strcase.ToGoPascal(fieldName)+"Item", *fieldProp.Items)
		}
	}
}

func generateStructFields(file *bytes.Buffer, name string, prop Property, excludeFields []string) {
	requiredFields := make(map[string]bool)
	for _, field := range prop.Required {
		requiredFields[field] = true
	}

	for fieldName, fieldProp := range prop.Properties {
		if slices.Contains(excludeFields, fieldName) {
			continue
		}
		pascalFieldName := strcase.ToGoPascal(fieldName)
		var fieldType string
		if fieldName == "metadata" {
			fieldType = "*k8s.ObjectMetaV1"
		} else {
			fieldType = getGoType(name+pascalFieldName, fieldProp)
		}

		if fieldProp.Description != "" {
			file.WriteString(fmt.Sprintf("\t// %s\n", strings.ReplaceAll(fieldProp.Description, "\n", " ")))
		}
		tag := fmt.Sprintf(`json:"%s`, fieldName)
		if !requiredFields[fieldName] {
			tag += ",omitempty"
			if !strings.HasPrefix(fieldType, "[]") && !strings.HasPrefix(fieldType, "*") && fieldType != "map[string]interface{}" {
				fieldType = "*" + fieldType
			}
		}
		tag += `"`
		file.WriteString(fmt.Sprintf("\t%s %s `%s`\n", pascalFieldName, fieldType, tag))
	}
}

func generateListStruct(file *bytes.Buffer, listKind, itemKind string, schema Property) {
	file.WriteString(fmt.Sprintf("type %s struct {\n", listKind))
	generateStructFields(file, listKind, schema, []string{"spec", "status"})
	file.WriteString(fmt.Sprintf("\tItems []%s `json:\"items\"`\n", itemKind))
	file.WriteString("}\n\n")
}

func getGoType(name string, prop Property) string {
	switch prop.Type {
	case "string":
		return "string"
	case "integer":
		return "int"
	case "boolean":
		return "bool"
	case "array":
		if prop.Items != nil {
			itemType := getGoType(name+"Item", *prop.Items)
			if prop.Items.Type == "object" {
				itemType = strcase.ToGoPascal(name + "Item")
			}
			return "[]" + itemType
		}
		return "[]interface{}"
	case "object":
		if len(prop.Properties) > 0 {
			return strcase.ToGoPascal(name)
		}
		return "map[string]interface{}"
	default:
		return "interface{}"
	}
}

func hasCustomName(input string) (string, string, bool) {
	pattern := `^(\w+):=(.*)$`
	re := regexp.MustCompile(pattern)

	matches := re.FindStringSubmatch(input)
	if len(matches) == 3 {
		name := matches[1]
		value := matches[2]
		return name, value, true
	} else {
		return "", "", false
	}
}

func isHTTPLink(s string) bool {
	u, err := url.Parse(s)
	if err != nil {
		return false
	}
	return u.Scheme == "http" || u.Scheme == "https"
}
