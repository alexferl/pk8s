package main

import (
	"fmt"
	"log"
	"os"
	"slices"
	"strings"
	"text/template"
	"unicode"

	"github.com/ettle/strcase"
	"github.com/pb33f/libopenapi"
	highbase "github.com/pb33f/libopenapi/datamodel/high/base"
	"github.com/pb33f/libopenapi/datamodel/high/v2"
	"github.com/pb33f/libopenapi/orderedmap"
)

type File struct {
	Name    string
	Package string
	Imports []string
	Struct  Struct
}

type Struct struct {
	Name        string
	Description string
	Fields      []Field
}

type Field struct {
	Comment string
	Name    string
	Type    string
	Tag     string
}

const structTemplate = `// Code generated by pk8s; DO NOT EDIT.

package {{.Package}}
{{ if .Imports}}
import (
{{- range .Imports}}
	"{{.}}"
{{- end}}
){{end}}

// {{.Struct.Name}} {{.Struct.Description}}
type {{.Struct.Name}} struct {
{{- range .Struct.Fields}}
{{- if .Comment}}
	// {{.Comment}}
{{- end}}
	{{.Name}} {{.Type}} {{.Tag}}
{{- end}}
}
`

type Processor struct {
	definitions *orderedmap.Map[string, *highbase.SchemaProxy]
	files       map[string]*File
}

func New() *Processor {
	return &Processor{
		files: make(map[string]*File),
	}
}

func (p *Processor) Process(data []byte) {
	document, err := libopenapi.NewDocument(data)
	if err != nil {
		log.Fatalf("failed creating new document: %e", err)
	}

	var errors []error
	var v2Model *libopenapi.DocumentModel[v2.Swagger]

	v2Model, errors = document.BuildV2Model()
	if len(errors) > 0 {
		for i := range errors {
			fmt.Printf("error: %e\n", errors[i])
		}
		log.Fatalf("cannot create v2 model from "+
			"document: %d errors reported", len(errors))
	}

	p.definitions = v2Model.Model.Definitions.Definitions
	for el := p.definitions.First(); el != nil; el = el.Next() {
		p.process(el.Value())
	}

	p.write()
}

func (p *Processor) append(file *File) {
	if len(file.Struct.Fields) < 1 {
		return
	}

	if _, ok := p.files[file.Name]; !ok {
		p.files[file.Name] = file
	}
}

func (p *Processor) process(def *highbase.SchemaProxy) {
	resourceType, versionTag := splitRef(def.GetSchemaKeyNode().Value)
	isJSONSchemaProps := resourceType == "JSONSchemaProps"

	file := &File{
		Name:    fmt.Sprintf("%s_%s.go", strcase.ToSnake(resourceType), strings.ToLower(versionTag)),
		Package: "k8s",
		Struct: Struct{
			Name:        fmt.Sprintf("%s%s", resourceType, versionTag),
			Description: strings.ReplaceAll(def.Schema().Description, "\n", " "),
		},
	}
	defer p.append(file)

	requiredField := def.Schema().Required
	for el := def.Schema().Properties.First(); el != nil; el = el.Next() {
		schema := el.Value().Schema()
		key := el.Key()

		tag := fmt.Sprintf("`json:\"%s", key)
		if !slices.Contains(requiredField, key) {
			tag += ",omitempty\"`"
		} else {
			tag += "\"`"
		}

		var typ string
		if !slices.Contains(requiredField, key) {
			typ += "*"
		}

		if !el.Value().IsReference() {
			if isJSONSchemaProps {
				switch key {
				case "enum":
					typ = "[]map[string]interface{}"
				case "allOf", "anyOf", "oneOf":
					typ = "[]JSONSchemaPropsV1"
				case "properties", "patternProperties", "definitions":
					typ = "map[string]JSONSchemaPropsV1"
				default:
					if strings.HasPrefix(key, "$") {
						key = strings.TrimPrefix(key, "$")
					}
				}
			}
			if schema.Format == "" {
				switch schema.Type[0] {
				case "array":
					if schema.Items.A.Schema().Format != "" {
						typ = fmt.Sprintf("[]%s", schema.Items.A.Schema().Format)
					} else if len(schema.Items.A.Schema().Type) > 0 && schema.Items.A.Schema().Type[0] != "" {
						typ = fmt.Sprintf("[]%s", schema.Items.A.Schema().Type[0])
					}
					if schema.Items.A.IsReference() && key != "enum" {
						ref := strings.TrimPrefix(schema.Items.A.GetReference(), "#/definitions/")
						if ref == "io.k8s.apimachinery.pkg.util.intstr.IntOrString" {
							typ += "string"
						} else {
							resourceType, versionTag = splitRef(ref)
							typ = fmt.Sprintf("[]%s%s", resourceType, capitalizeVersion(versionTag))
						}
					}
				case "boolean":
					typ += "bool"
				case "object":
					if !strings.HasSuffix(typ, "JSONSchemaPropsV1") {
						typ += "map[string]"
					}

					if schema.AdditionalProperties.IsA() {
						additionalProperties := schema.AdditionalProperties.A.Schema()
						if len(additionalProperties.Type) > 0 {
							switch additionalProperties.Type[0] {
							case "array":
								typ += fmt.Sprintf("[]%s", additionalProperties.Items.A.Schema().Type[0])
							case "string":
								typ += "string"
							case "object":
								if !strings.HasSuffix(typ, "JSONSchemaPropsV1") {
									typ += "map[string]interface{}"
								}
							default:
								log.Fatalf("Unhandled additionalProperties type %s %s\n", key, additionalProperties.Type[0])
							}
						} else {
							typ += "interface{}"
						}
					}
				default:
					typ += schema.Type[0]
				}
			} else {
				switch schema.Format {
				case "byte":
					typ = "[]byte"
				case "double":
					typ += "float64"
				default:
					typ += schema.Format
				}
			}
		} else {
			if isJSONSchemaProps {
				switch key {
				case "additionalItems", "additionalProperties", "default", "enum", "example", "items":
					typ = "map[string]interface{}"
				case "externalDocs", "not":
					ref := strings.TrimPrefix(el.Value().GetReference(), "#/definitions/")
					resourceType, versionTag = splitRef(ref)
					typ += fmt.Sprintf("%s%s", resourceType, versionTag)
				}
			} else {
				ref := strings.TrimPrefix(el.Value().GetReference(), "#/definitions/")
				if ref == "io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime" || ref == "io.k8s.apimachinery.pkg.apis.meta.v1.Time" {
					typ += "time.Time"
					if !slices.Contains(file.Imports, "time") {
						file.Imports = append(file.Imports, "time")
					}
				} else if ref == "io.k8s.apimachinery.pkg.util.intstr.IntOrString" || ref == "io.k8s.apimachinery.pkg.api.resource.Quantity" {
					typ += "string"
				} else {
					resourceType, versionTag = splitRef(ref)
					typ += fmt.Sprintf("%s%s", resourceType, versionTag)
				}
			}
		}

		// TODO: handle properly above
		if typ == "RawExtensionRuntime" || typ == "*RawExtensionRuntime" || typ == "*FieldsV1V1" || typ == "StorageVersionSpecV1alpha1" || typ == "*CustomResourceSubresourceStatusV1" {
			typ = "map[string]interface{}"
		}

		field := Field{
			Comment: strings.ReplaceAll(schema.Description, "\n", " "),
			Name:    caser.ToPascal(key),
			Tag:     tag,
			Type:    typ,
		}

		file.Struct.Fields = append(file.Struct.Fields, field)

		if el.Value().IsReference() {
			ref := strings.TrimPrefix(el.Value().GetReference(), "#/definitions/")
			if ref != "io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.JSONSchemaProps" {
				def, _ = p.definitions.Get(ref)
				p.process(def)
			}
		}
	}
}

func (p *Processor) write() {
	if err := os.MkdirAll("k8s", 0o755); err != nil {
		log.Fatalf("failed to create k8s directory: %v", err)
	}

	for _, file := range p.files {
		writeFile(file)
	}
}

func writeFile(file *File) {
	out, err := os.Create(fmt.Sprintf("k8s/%s", file.Name))
	if err != nil {
		log.Fatalf("failed creating file: %v", err)
	}
	defer out.Close()

	tmpl, err := template.New("structTemplate").Parse(structTemplate)
	if err != nil {
		log.Fatalf("failed creating template: %v", err)
	}

	err = tmpl.Execute(out, file)
	if err != nil {
		log.Fatalf("failed executing template: %v", err)
	}
}

func splitRef(ref string) (string, string) {
	parts := strings.Split(ref, ".")
	versionTag := parts[len(parts)-2]
	resourceType := parts[len(parts)-1]
	return resourceType, capitalizeVersion(versionTag)
}

func capitalizeVersion(version string) string {
	if len(version) > 0 {
		runes := []rune(version)
		runes[0] = unicode.ToUpper(runes[0])
		return string(runes)
	}
	return version
}
