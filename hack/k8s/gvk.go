package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"
)

type Swagger struct {
	Definitions map[string]Definition `json:"definitions"`
}

type Definition struct {
	XKubernetesGroupVersionKind []struct {
		Group   string `json:"group"`
		Version string `json:"version"`
		Kind    string `json:"kind"`
	} `json:"x-kubernetes-group-version-kind"`
}

func generateGroupVersionKind(data []byte) {
	var swagger Swagger
	err := json.Unmarshal(data, &swagger)
	if err != nil {
		log.Fatalf("failed to unmarshal JSON: %v", err)
	}

	var cases []string
	var testCases []string
	var testAssertions []string

	for _, def := range swagger.Definitions {
		for _, gvk := range def.XKubernetesGroupVersionKind {
			// Skip
			if gvk.Kind == "DeleteOptions" || gvk.Kind == "WatchEvent" || gvk.Kind == "TokenRequest" || strings.HasSuffix(gvk.Kind, "List") {
				continue
			}

			// Special handling for Event: only include if it's "events.k8s.io/v1"
			if gvk.Kind == "Event" && !(gvk.Group == "events.k8s.io" && gvk.Version == "v1") {
				continue
			}

			// Special handling for Status: skip if it's "resource.k8s.io/v1alpha2"
			if gvk.Kind == "Status" && gvk.Group == "resource.k8s.io" && gvk.Version == "v1alpha2" {
				continue
			}

			var apiVersion string
			if gvk.Group == "" {
				apiVersion = gvk.Version
			} else {
				apiVersion = fmt.Sprintf("%s/%s", gvk.Group, gvk.Version)
			}

			capitalizedVersion := capitalizeVersion(gvk.Version)

			caseStr := fmt.Sprintf("case *%s%s:\n\t\tv.APIVersion = String(\"%s\")\n\t\tv.Kind = String(\"%s\")\n", gvk.Kind, capitalizedVersion, apiVersion, gvk.Kind)
			cases = append(cases, caseStr)

			testCaseStr := fmt.Sprintf(`{
				name:       "%s%s",
				input:      &%s%s{},
				wantApiVer: "%s",
				wantKind:   "%s",
			},`, gvk.Kind, capitalizedVersion, gvk.Kind, capitalizedVersion, apiVersion, gvk.Kind)
			testCases = append(testCases, testCaseStr)

			testAssertionStr := fmt.Sprintf(`case *%s%s:
				assert.Equal(t, tt.wantApiVer, *obj.APIVersion)
				assert.Equal(t, tt.wantKind, *obj.Kind)
`, gvk.Kind, capitalizedVersion)
			testAssertions = append(testAssertions, testAssertionStr)
		}
	}

	// Sort the cases by kind
	sort.Strings(cases)
	sort.Strings(testCases)
	sort.Strings(testAssertions)

	switchFunction := "// Code generated by pk8s; DO NOT EDIT.\n\npackage k8s\n\nfunc SetAPIVersionAndKind(i any) {\n\tswitch v := i.(type) {\n"
	for _, caseStr := range cases {
		switchFunction += "\t" + caseStr
	}
	switchFunction += "\t}\n}\n"

	testFunction := `// Code generated by pk8s; DO NOT EDIT.

package k8s

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestSetAPIVersionAndKind(t *testing.T) {
	tests := []struct {
		name       string
		input      any
		wantApiVer string
		wantKind   string
	}{
`
	for _, testCaseStr := range testCases {
		testFunction += "\t\t" + testCaseStr + "\n"
	}
	testFunction += `	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			SetAPIVersionAndKind(tt.input)

			switch obj := tt.input.(type) {
`
	for _, testAssertionStr := range testAssertions {
		testFunction += "\t\t\t" + testAssertionStr
	}
	testFunction += `			}
		})
	}
}
`

	err = os.WriteFile("k8s/gvk.go", []byte(switchFunction), 0o644)
	if err != nil {
		log.Fatalf("failed to write to file: %v", err)
	}

	err = os.WriteFile("k8s/gvk_test.go", []byte(testFunction), 0o644)
	if err != nil {
		log.Fatalf("failed to write test file: %v", err)
	}
}

func generateUtils() {
	content := `// Code generated; DO NOT EDIT.

package k8s

import (
	"time"
)

// Bool is a helper routine that returns a pointer to given boolean value.
func Bool(v bool) *bool { return &v }

// Int is a helper routine that returns a pointer to given integer value.
func Int(v int) *int { return &v }

// Int32 is a helper routine that returns a pointer to given integer value.
func Int32(v int32) *int32 { return &v }

// Int64 is a helper routine that returns a pointer to given integer value.
func Int64(v int64) *int64 { return &v }

// Float32 is a helper routine that returns a pointer to given float value.
func Float32(v float32) *float32 { return &v }

// Float64 is a helper routine that returns a pointer to given float value.
func Float64(v float64) *float64 { return &v }

// String is a helper routine that returns a pointer to given string value.
func String(v string) *string { return &v }

// Time is helper routine that returns a pointer to given Time value.
func Time(v time.Time) *time.Time { return &v }
`

	err := os.WriteFile("k8s/utils.go", []byte(content), 0o644)
	if err != nil {
		log.Fatalf("failed writing to file: %v\n", err)
	}
}
